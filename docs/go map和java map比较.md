- [go map实现要比java map好么 - 掘金](https://juejin.cn/post/7066528623297036302)
	- **底层实现**：
		- 都是基于哈希表的分离链接法实现，
		- go map是数组+bmap链表（bmap本身包含8个key/value对）
		- java 1.8 JDK1.8链表 >8 的时候转换为红黑树
	- hash table
		- 组table的长度length大小必须为2的n次方(一定是合数)，
		- 这对于 hash 来说是一种非常规的设计，常规的设计是把桶的大小设计为素数。
		- 相对来说素数导致冲突的概率要小于合数，具体证明可以参考[这篇文章](http://blog.csdn.net/liuqiyao_01/article/details/14475159)
		- 高低位差异化
			- HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程,
				- ![](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/45205ec2.png)
			- go bmap 也用到了 [[top hash]]
	- **负载因子**：
		- go map 6.5，java map 0.75，
		- 本质上来讲二者其实是差不多的，因为go中bmap可存储8个kv对
		- （单个bmap可以认为是链表单个节点）
		- 6.5/8=0.8，跟0.75也差不多。
	- **扩容机制**：
		- go map是增量rehash，每次set操作时可能会移动一些数据，
		- 而java map是一次性完成的，这个相对来说go实现性能要好点，
		- 但是由于日常开发rehash次数不频繁，因此可能好的不明显。
	- **内存占用**：
		- go map一次性申请维度至少bmap大小，
		- 而java map可单个key/value申请添加，
		- 相对来讲go map有点空间换时间的意思。
		- go map数据删除为逻辑删除并未及时释放内存，不过可能不久就被复用了，
		- 而java则是随取随用。
	- **代码可读性**：
		- 这一点来说java map比较好，go中有很多指针操作，看着有点头大。
	- **性能对比**：
		- 由于二者底层实现原理类似，因此读写性能不会有数量级别的差距，但是可能会有一些差异。
	- 并发不安全
		- 无锁
		- 且扩容等操作不是原子的