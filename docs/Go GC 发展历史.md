- GC 算法
	- v1.1	STW(stop the word)
	- v1.3	Mark STW,Sweep (标记清除)
	- v1.5	三色标记
	- v1.8	hybrid write barrier (三色标记基础上加入写屏障)
- Go V1.3之前的标记-清除(mark and sweep)算法 #card
- Go V1.3之前的标记-清除(mark and sweep)的缺点#card
	- STW，stop the world，STW 让程序暂停，程序出现卡顿 **(重要问题)**。
	- 标记需要扫描整个heap
	- 清除数据会产生heap碎片
- Go V1.5的三色并发标记法#card
	- “强-弱” [[三色不变式]]
	- [[插入屏障]]
	- [[删除屏障]] )
- Go V1.5的[[三色标记]]为什么需要STW #card
-
- Go V1.8[[混合写屏障]]机制
- Go V1.8混合写屏障机制的全场景分析
-
- Go 1.10 和 Go 1.11 中，Go 实现了[[批量写屏障机制]]。
	- 其基本想法是将需要着色的指针统一写入一个缓存， 每当缓存满时统一对缓存中的所有 ptr 指针进行着色。
-
-
- 为什么没用分代
	- 分代 GC 依赖一个基本的假设：大部分对象 (或其他数据结构) 只使用一小段时间就不再被使用了
	- 但是 Go 语言使用了并发 GC